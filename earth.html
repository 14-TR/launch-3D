<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgpu - sphere in space</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let camera, scene, renderer, controls, sphere, axesHelper;

        init();

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 3;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Load Earth texture
            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load('https://raw.githubusercontent.com/14-TR/webgpu-earth/main/textures/earth_day_2k.jpg');

            // Sphere with texture
            const geometry = new THREE.SphereGeometry(1, 64, 64);
            const material = new THREE.MeshStandardMaterial({ map: earthTexture, roughness: 0.5 });
            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);

            // Coordinate System - Axes Helper
            axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);

            // Latitude/Longitude Lines
            const latLongGroup = new THREE.Group();
            const latSegments = 9;
            const lonSegments = 18;

            for (let i = 1; i < latSegments; i++) {
                const latAngle = (i / latSegments) * Math.PI - Math.PI / 2;
                const latRadius = Math.cos(latAngle);
                const latY = Math.sin(latAngle);

                const latPoints = [];
                const segments = 64;
                for (let k = 0; k <= segments; k++) {
                    const theta = (k / segments) * 2 * Math.PI;
                    latPoints.push(new THREE.Vector3(Math.cos(theta) * latRadius, latY, Math.sin(theta) * latRadius));
                }
                const latGeometry = new THREE.BufferGeometry().setFromPoints(latPoints);
                const latMaterial = new THREE.LineBasicMaterial({ color: 0x4444ff });
                const latLine = new THREE.LineLoop(latGeometry, latMaterial);
                latLongGroup.add(latLine);
            }

            for (let j = 0; j < lonSegments; j++) {
                const lonPoints = [];
                const segments = 64;
                const lonAngle = (j / lonSegments) * 2 * Math.PI;
                for (let k = 0; k <= segments; k++) {
                    const phi = (k / segments) * Math.PI - Math.PI / 2;
                    lonPoints.push(new THREE.Vector3(
                        Math.cos(phi) * Math.cos(lonAngle),
                        Math.sin(phi),
                        Math.cos(phi) * Math.sin(lonAngle)
                    ));
                }
                const lonGeometry = new THREE.BufferGeometry().setFromPoints(lonPoints);
                const lonMaterial = new THREE.LineBasicMaterial({ color: 0x44ff44 });
                const lonLine = new THREE.Line(lonGeometry, lonMaterial);
                latLongGroup.add(lonLine);
            }

            scene.add(latLongGroup);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            sphere.rotation.y += 0.001;
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
